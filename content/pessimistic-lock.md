悲观锁思考

* 最初 tidb 为什么要做 select for update?

解决 SI 隔离级别下的 write skew 问题

* 能描述一下 write skew 么？

在 SI 隔离级别下面，存在一种的异常

事务1 读 a 写 b
事务2 读 b 写 a

* select for update 是如何解决 write skew 问题的？

select for update 对读操作也加锁了

* select for update 有什么痛点？

发生冲突时，不会自动重试，因此，对业务不友好，需要在业务层实现冲突重试

* 为什么不自动重试呢？

自动重试时的 select 结果，跟最初的 select 结果不一样。
之前的结果已经通知给客户了，然而自动重试这个事件却没有。

* 那么，什么情况下能重试呢？

已经读到的值，再次读，一定跟上次是一样的

一种是锁住不让人改
另一种是读快照

* 悲观锁想解决什么问题？

* 实现的方向是怎么样的呢？

读操作的时候就加锁。使当前事务预先抢占资源，不会到提交阶段才去检测冲突并重试

* select for update 的东西，跟 update 的东西不一致，会发生什么事情？

* 当涉及索引修改的时候呢？

* 死锁以及处理

事务1 锁住了资源a，要去申请资源b
事务2 锁住了资源b，要去申请资源a



* 重新获取 ts 能保证正确性么？
